use crate::sat::cp_model::{Constraint, IntVar};

pub mod routing;
pub mod routing_enums;
pub mod routing_index_manager;
pub mod routing_parameters;
pub mod solver_parameters;

// IMPORT CXX LIBRARY
cpp! {{
    #include "ortools/constraint_solver/constraint_solver.h"
}}

cpp_class!(
    /// Solver Class
    ///
    /// A solver represents the main computation engine. It implements the entire
    /// range of Constraint Programming protocols:
    ///   - Reversibility
    ///   - Propagation
    ///   - Search
    ///
    /// Usually, Constraint Programming code consists of
    ///   - the creation of the Solver,
    ///   - the creation of the decision variables of the model,
    ///   - the creation of the constraints of the model and their addition to the
    ///     solver() through the AddConstraint() method,
    ///   - the creation of the main DecisionBuilder class,
    ///   - the launch of the solve() method with the decision builder.
    ///
    /// For the time being, Solver is neither MT_SAFE nor MT_HOT.
    pub unsafe struct Solver as "operations_research::Solver"
);

impl Solver {
    /// Adds the constraint 'c' to the model.
    ///
    /// After calling this method, and until there is a backtrack that undoes the
    /// addition, any assignment of variables to values must satisfy the given
    /// constraint in order to be considered feasible. There are two fairly
    /// different use cases:
    ///
    /// - the most common use case is modeling: the given constraint is really
    /// part of the problem that the user is trying to solve. In this use case,
    /// AddConstraint is called outside of search (i.e., with <tt>state() ==
    /// OUTSIDE_SEARCH</tt>). Most users should only use AddConstraint in this
    /// way. In this case, the constraint will belong to the model forever: it
    /// cannot not be removed by backtracking.
    ///
    /// - a rarer use case is that 'c' is not a real constraint of the model. It
    /// may be a constraint generated by a branching decision (a constraint whose
    /// goal is to restrict the search space), a symmetry breaking constraint (a
    /// constraint that does restrict the search space, but in a way that cannot
    /// have an impact on the quality of the solutions in the subtree), or an
    /// inferred constraint that, while having no semantic value to the model (it
    /// does not restrict the set of solutions), is worth having because we
    /// believe it may strengthen the propagation. In these cases, it happens
    /// that the constraint is added during the search (i.e., with state() ==
    /// IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is
    /// added during a search, it applies only to the subtree of the search tree
    /// rooted at the current node, and will be automatically removed by
    /// backtracking.
    ///
    /// This method does not take ownership of the constraint. If the constraint
    /// has been created by any factory method (Solver::MakeXXX), it will
    /// automatically be deleted. However, power users who implement their own
    /// constraints should do: solver.AddConstraint(solver.RevAlloc(new
    /// MyConstraint(...));
    pub fn add_constraint(&mut self, c: Box<Constraint>) {
        let c = Box::leak(c);

        unsafe {
            cpp!([
                self as "operations_research::Solver*",
                c as "operations_research::Constraint*"
            ]
                {
                    return self->AddConstraint(c);
                }
            )
        }
    }

    /// Return an constraint that tests `a` == `b`
    pub fn make_equality(&mut self, a: &IntVar, b: &IntVar) -> Box<Constraint> {
        unsafe {
            cpp!([
                self as "operations_research::Solver*",
                a as "operations_research::IntVar*",
                b as "operations_research::IntVar*"
            ] -> Box<Constraint> as "operations_research::Constraint*"
                {
                    return self->MakeEquality(a, b);
                }
            )
        }
    }

    /// Return an constraint that tests  `a` <= `b`
    pub fn make_less_or_equal(&mut self, a: &IntVar, b: &IntVar) -> Box<Constraint> {
        unsafe {
            cpp!([
                self as "operations_research::Solver*",
                a as "operations_research::IntVar*",
                b as "operations_research::IntVar*"
            ] -> Box<Constraint> as "operations_research::Constraint*"
                {
                    return self->MakeLessOrEqual(a, b);
                }
            )
        }
    }
}

cpp_class!(
    /// An Assignment is a variable -> domains mapping, used
    /// to report solutions to the user.
    pub unsafe struct Assignment as "operations_research::Assignment"
);
